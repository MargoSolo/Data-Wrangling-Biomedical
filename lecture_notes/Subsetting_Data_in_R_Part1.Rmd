---
title: "Subsetting Data in R"
author: "Data Wrangling in R"
output:
  ioslides_presentation:
    css: styles.css
  beamer_presentation: default
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(comment = "")
suppressPackageStartupMessages(library(dplyr))
library(dplyr)
```

## Overview

We showed different ways to read  data into R using `readr::read_csv()`, `readr::read_delim()` and `readxl::read_excel()`.  In this module, we will show you how select rows and columns of datasets. 

## Setup

We will be using the `dplyr` package in the tidyverse.

Many resources on how to use `dplyr` exist and are straightforward: 

* https://dplyr.tidyverse.org/
* https://r4ds.had.co.nz/
* https://cran.rstudio.com/web/packages/dplyr/vignettes/dplyr.html
* https://stat545.com/dplyr-intro.html

The `dplyr` package also interfaces well with tibbles.

## 


## Subset columns of a `data.frame`: 

We can grab the `carb` column using the `$` operator. 

```{r}
df$carb
```


## Subset columns of a `data.frame`: dplyr

If you wanted it to be a single vector (not a `tibble`), use `pull`:
```{r}
pull(select(df, mpg))
```


## Subset columns of a `data.frame`: dplyr

The `select` command from `dplyr` allows you to subset
```{r}
select(df, car, mpg)
```

## Subset columns of a `data.frame`: 

We can grab the `carb` column using the `$` operator. 

```{r}
df$carb
```

## Select columns of a `data.frame`: dplyr

The `select` command from `dplyr` allows you to subset columns of 
```{r}
select(df, car, mpg, cyl)
select(df, starts_with("c"))
```


## See the Select "helpers"

Run the command:

```{r, eval = FALSE}
??tidyselect::select_helpers
```

Here are a few:

```{r, eval = FALSE}
one_of()
last_col()
ends_with()
contains() # like searching
matches() # Matches a regular expression - cover later
```

## Lab Part 2

[Website](https://sisbid.github.io/Module1/)

## Subset rows of a `data.frame`: dplyr

The command in `dplyr` for subsetting rows is `filter`.  Try `?filter`

```{r}
filter(df, mpg > 20 | mpg < 14)
```
Note, no `$` or subsetting is necessary.  R "knows" `mpg` refers to a column of `df`.


## Subset rows of a `data.frame`: dplyr

You can have multiple logical conditions using the following:

* `&` : AND
* `|` : OR

By default, you can separate conditions by commas, and `filter` assumes these statements are joined by `&`:

```{r}
filter(df, mpg > 20 & cyl == 4)
filter(df, mpg > 20, cyl == 4)
```

## Subset rows of a `data.frame`: dplyr

If you want OR statements, you need to do the pipe `|` explicitly:

```{r}
filter(df, mpg > 20 | cyl == 4)
```


## Lab Part 3

[Website](https://sisbid.github.io/Module1/)

## Combining `filter` and `select`

You can combine `filter` and `select` to subset the rows and columns, respectively, of a `data.frame`:

```{r}
select(filter(df, mpg > 20 & cyl == 4), car,cyl, hp)
```

In `R`, the common way to perform multiple operations is to wrap functions around each other in a nested way such as above 

## Assigning Temporary Objects

One can also create temporary objects and reassign them:

```{r}
df2 = filter(df, mpg > 20 & cyl == 4)
df2 = select(df2,car, cyl, hp)
```

## Using the `pipe` (comes with `dplyr`):

Recently, the pipe `%>%` makes things such as this much more readable.  It reads left side "pipes" into right side.  RStudio `CMD/Ctrl + Shift + M` shortcut. Pipe `df` into `filter`, then pipe that into `select`:


```{r}
df %>% filter(mpg > 20 & cyl == 4) %>% select(car, cyl, hp)
```


# Adding/Removing Columns

## Adding new columns to a `data.frame`: base R

You can add a new column, called `newcol` to `df`, using the `$` operator:
```{r}
df$newcol = df$wt/2.2
head(df,3)
```


## Adding columns to a `data.frame`: dplyr

The `$` method is very common.

The `mutate` function in `dplyr` allows you to add or replace columns of a `data.frame`:
```{r}
df = mutate(df, newcol = wt/2.2)
```

```{r, echo = FALSE}
print({df = mutate(df, newcol = wt/2.2)})
```


## Creating conditional variables

One frequently-used tool is creating variables with conditions.

A general function for creating new variables based on existing variables is the `ifelse()` function, which "returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is `TRUE` or `FALSE`."

```
ifelse(test, yes, no)

# test: an object which can be coerced
    to logical mode.
# yes: return values for true elements of test.
# no: return values for false elements of test.
```


## Adding columns to a `data.frame`: dplyr

Combined with `ifelse(condition, TRUE, FALSE)`, it can give you:

```{r}
df = mutate(df, 
            disp_cat = ifelse(
              disp <= 200,
              "Low",
              ifelse(disp <= 400,
                     "Medium",
                     "High")
            )
)
head(df$disp_cat)
```

## Adding columns to a `data.frame`: dplyr

Alternatively, `case_when` provides a clean syntax as well:

```{r}
df = mutate(df, 
            disp_cat2 = case_when(
              disp <= 200 ~ "Low",
              disp > 200 & disp <= 400 ~ "Medium",
              disp > 400 ~ "High",
            ))
head(df$disp_cat2)
```

## Removing columns to a `data.frame`: base R

You can remove a column by assigning to `NULL`:
```{r, eval = FALSE}
df$newcol = NULL
```

## Removing columns to a `data.frame`: dplyr

The `NULL` method is still very common.

The `select` function can remove a column with a minus (`-`), much like removing rows:
```{r}
select(df, -newcol)
```

## Removing columns to a `data.frame`: dplyr

Remove `newcol` and `drat`
```{r}
select(df, -one_of("newcol", "drat"))
```


# Ordering columns

## Ordering the columns of a `data.frame`: dplyr

The `select` function can reorder columns.  Put `newcol` first, then select the rest of columns:
```{r}
select(df, newcol, everything())
```

# Ordering rows

## Ordering the rows of a `data.frame`: dplyr

The `arrange` function can reorder rows  By default, `arrange` orders in ascending order:
```{r}
arrange(df, mpg)
```

## Ordering the rows of a `data.frame`: dplyr
Use the `desc` to arrange the rows in descending order:
```{r}
arrange(df, desc(mpg))
```

## Ordering the rows of a `data.frame`: dplyr
It is a bit more straightforward to mix increasing and decreasing orderings:
```{r}
arrange(df, mpg, desc(hp))
```

## Transmutation

The `transmute` function in `dplyr` combines both the `mutate` and `select` functions. One can create new columns and keep the only the columns wanted:

```{r}
transmute(df, newcol2 = wt/2.2, mpg, hp)
```

## Lab Part 4

[Website](https://sisbid.github.io/Module1/)


# Base R syntax (extra)

## Select specific elements using an index

Often you only want to look at subsets of a data set at any given time. As a review, elements of an R object are selected using the brackets (`[` and `]`).

For example, `x` is a vector of numbers and we can select the second element of `x` using the brackets and an index (2):

```{r}
x = c(1, 4, 2, 8, 10)
x[2]
```

## Select specific elements using an index

We can select the fifth or second AND fifth elements below:

```{r}
x = c(1, 2, 4, 8, 10)
x[5]
x[c(2,5)]
```

## Subsetting by deletion of entries

You can put a minus (`-`) before integers inside brackets to remove these indices from the data.

```{r negativeIndex}
x[-2] # all but the second
```
Note that you have to be careful with this syntax when dropping more than 1 element:

```{r negativeIndex2}
x[-c(1,2,3)] # drop first 3
# x[-1:3] # shorthand. R sees as -1 to 3
x[-(1:3)] # needs parentheses
```

## Select specific elements using logical operators

What about selecting rows based on the values of two variables? We use logical statements.  Here we select only elements of `x` greater than 2:

```{r}
x
x > 2
x[ x > 2 ]
```

## Select specific elements using logical operators
You can have multiple logical conditions using the following:

* `&` : AND
* `|` : OR

```{r}
x[ x > 2 & x < 5 ]
x[ x > 5 | x == 2 ]
```


## which function

The `which` functions takes in logical vectors and returns the index for the elements where the logical value is `TRUE`.  

```{r}
which(x > 5 | x == 2) # returns index
x[ which(x > 5 | x == 2) ]
x[ x > 5 | x == 2 ]
```


## Renaming Columns of a `data.frame`: base R

We can use the `colnames` function to directly reassign column names of `df`:
```{r}
colnames(df)[1:3] = c("MPG", "CYL", "DISP")
head(df)
colnames(df)[1:3] = c("mpg", "cyl", "disp") #reset
```

## Renaming Columns of a `data.frame`: base R

We can assign the column names, change the ones we want, and then re-assign
the column names:
```{r}
cn = colnames(df)
cn[ cn == "drat"] = "DRAT"
colnames(df) = cn
head(df)
colnames(df)[ colnames(df) == "DRAT"] = "drat" #reset
```


## Subset columns of a `data.frame`: 

We can grab the `carb` column using the `$` operator. 

```{r}
df$carb
```

## Subset columns of a `data.frame`: 

We can also subset a `data.frame` using the bracket `[, ]` subsetting. 

For `data.frame`s and matrices (2-dimensional objects), the brackets are `[rows, columns]` subsetting.  We can grab the `x` column using the index of the column or the column name ("`carb`") 

```{r}
df[, 11]
df[, "carb"]
```


## Biggest difference between `tbl` and `data.frame`: 

Mostly, `tbl` (tibbles) are the same as `data.frame`s, except they don't print all lines.  When subsetting only one column using brackets, a `data.frame` will return a vector, but a `tbl` will return a `tbl`

```{r}
df[, 1]
tbl[, 1]
tbl[, "mpg"]
df[, 1, drop = FALSE]
```

## Subset columns of a `data.frame`: 

We can select multiple columns using multiple column names:

```{r}
df[, c("mpg", "cyl")]
```


# Subsetting Rows

## Subset rows of a `data.frame` with indices: 

Let's select **rows** 1 and 3 from `df` using brackets:

```{r}
df[ c(1, 3), ]
```
